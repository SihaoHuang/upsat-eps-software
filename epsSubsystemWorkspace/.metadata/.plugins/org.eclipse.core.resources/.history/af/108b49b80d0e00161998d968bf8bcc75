
#include "hal_eps.h"



void EPS_PowerModule_init(EPS_PowerModule *module_X, uint32_t starting_pwm_dutycycle, TIM_HandleTypeDef *htim, uint32_t timer_channel){

	module_X->current =0;
	module_X->voltage =0;
	module_X->previous_power =0;
	module_X->pwm_duty_cycle = starting_pwm_dutycycle;
	//module_X->module_id = module_id;
	module_X->htim_pwm = htim;
	module_X->timChannel = timer_channel;
	module_X->incremennt_flag = 1;
}

void EPS_PowerModule_mppt_update_pwm(EPS_PowerModule *moduleX){

	//static uint8_t increment_flag = 1;//diplotriplotsekare oti to inint to kanei mono sthn arxh vlaks


	  /*power calculation*/

	  volatile uint32_t power_now_avg = moduleX->voltage * moduleX->current;
	  uint32_t duty_cycle = moduleX->pwm_duty_cycle;

	// decide duty cycle orientation - set increment flag.
	  if (power_now_avg  <(moduleX->previous_power)){

		  if (moduleX->incremennt_flag>0){
			  moduleX->incremennt_flag = 0;
		  }
		  else{
			  moduleX->incremennt_flag = 1;
		  }
	  }
    //add appropriate offset - create new duty cycle.


	  if(moduleX->incremennt_flag){
		  duty_cycle = duty_cycle+MPPT_STEP_SIZE;
	  }
	  else{
		  duty_cycle = duty_cycle-MPPT_STEP_SIZE;
	  }
 	  //Check for Overflow and Underflow
	  if (duty_cycle>350){duty_cycle=0;}
	  if (duty_cycle>320){duty_cycle=310;}
    // Set new PWM compare register
	  //duty_cycle =0;


	  moduleX->previous_power = power_now_avg;
	  moduleX->pwm_duty_cycle = duty_cycle;

}

void EPS_PowerModule_mppt_apply_pwm(EPS_PowerModule *moduleX){

	switch ( moduleX->timChannel ) {
	case 1:         /*  top module */
		moduleX->htim_pwm->Instance->CCR1 = moduleX->pwm_duty_cycle;
		break;
	case 2:         /*  bottom module */
		moduleX->htim_pwm->Instance->CCR2 = moduleX->pwm_duty_cycle;
		break;
	case 3:         /*  left module */
		moduleX->htim_pwm->Instance->CCR3 = moduleX->pwm_duty_cycle;
		break;
	case 4:         /*  right module */
		moduleX->htim_pwm->Instance->CCR4 = moduleX->pwm_duty_cycle;
		break;
	default:
		//error handling?
		break;
	}

}

void EPS_update_state(volatile EPS_State *state){

	/*adc ting*/
	ADC_EPS_STATE_Init();

	adc_reading_complete = 0;
	HAL_ADC_Start_DMA(&hadc, adc_measurement_dma_eps_state, 12);
	/*Wait till DMA ADC sequence transfer is ready*/
	while(adc_reading_complete==0){
 	}

//	HAL_ADC_Stop_DMA(&hadc);

	state->battery_voltage = adc_measurement_dma_eps_state[6];
	state->battery_current_plus = adc_measurement_dma_eps_state[7];
	state->battery_current_minus = adc_measurement_dma_eps_state[8];
	state->v3_3_current_avg = adc_measurement_dma_eps_state[9];
	state->v5_current_avg = adc_measurement_dma_eps_state[10];
	state->cpu_temperature = adc_measurement_dma_eps_state[11];

	/*i2c temp sensors*/
	//	  state->battery_temp;


}



void EPS_update_power_modules_state(EPS_PowerModule *module_top, EPS_PowerModule *module_bottom, EPS_PowerModule *module_left, EPS_PowerModule *module_right){

	/*adc ting*/
	ADC_EPS_POWER_MODULES_Init();
	adc_reading_complete = 0;
	HAL_ADC_Start_DMA(&hadc, adc_measurement_dma_power_modules, 136);

	/*Process Measurements*/
	uint32_t voltage_avg_top =0;
	uint32_t current_avg_top =0;
	uint32_t voltage_avg_bottom =0;
	uint32_t current_avg_bottom =0;
	uint32_t voltage_avg_left =0;
	uint32_t current_avg_left =0;
	uint32_t voltage_avg_right =0;
	uint32_t current_avg_right =0;

	/*Wait till DMA ADC sequence transfer is ready*/
	while(adc_reading_complete==0){
		//wait for dma transfer complete.
	}
//	HAL_ADC_Stop_DMA(&hadc);//stop transfer and turn off adc peripheral.

	//de-interleave and sum voltage and current measurements.
	for (int sum_index = 8; sum_index < 136; sum_index+=8) {
		/*top*/
		current_avg_top = current_avg_top + adc_measurement_dma_power_modules[sum_index];
		voltage_avg_top = voltage_avg_top + adc_measurement_dma_power_modules[sum_index+1];
		/*bottom*/
		current_avg_bottom = current_avg_bottom + adc_measurement_dma_power_modules[sum_index+2];
		voltage_avg_bottom = voltage_avg_bottom + adc_measurement_dma_power_modules[sum_index+3];
		/*left*/
		current_avg_left = current_avg_left + adc_measurement_dma_power_modules[sum_index+4];
		voltage_avg_left = voltage_avg_left + adc_measurement_dma_power_modules[sum_index+5];
		/*right*/
		current_avg_right = current_avg_right + adc_measurement_dma_power_modules[sum_index+6];
		voltage_avg_right = voltage_avg_right + adc_measurement_dma_power_modules[sum_index+7];
	}

	/*filter ting*/
	//average of 16 concecutive adc measurements.skip the first to avoid adc power up distortion.
	module_top->voltage = voltage_avg_top>>4;
	module_top->current = current_avg_top>>4;
	module_bottom->voltage = voltage_avg_bottom>>4;
	module_bottom->current = current_avg_bottom>>4;
	module_left->voltage = voltage_avg_left>>4;
	module_left->current = current_avg_left>>4;
	module_right->voltage = voltage_avg_right>>4;
	module_right->current = current_avg_right>>4;





}
